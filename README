# Algorithms and Data Structures in TypeScript

This repository contains implementations of various algorithms and data structures in TypeScript. It is designed to help individuals prepare for software engineering interviews where these concepts are crucial.

## Table of Contents

1. [Arrays](#arrays)
2. [Linked Lists](#linked-lists)
3. [Stacks](#stacks)
4. [Queues](#queues)
5. [Hash Tables (Hash Maps)](#hash-tables-hash-maps)
6. [Trees](#trees)
7. [Graphs](#graphs)
8. [Advanced Data Structures](#advanced-data-structures)
9. [Algorithms](#algorithms)
   - [Sorting Algorithms](#sorting-algorithms)
   - [Searching Algorithms](#searching-algorithms)
   - [Graph Algorithms](#graph-algorithms)
   - [Dynamic Programming](#dynamic-programming)
   - [Greedy Algorithms](#greedy-algorithms)
   - [Divide and Conquer](#divide-and-conquer)
   - [Backtracking](#backtracking)
   - [String Algorithms](#string-algorithms)
10. [Additional Concepts](#additional-concepts)
    - [Bit Manipulation](#bit-manipulation)
    - [Recursion](#recursion)

## Arrays

### Static and Dynamic Arrays

- **Static Arrays:** Fixed size arrays, straightforward to implement but lack flexibility.
- **Dynamic Arrays:** Arrays that resize automatically when they reach capacity, providing more flexibility but requiring more complex memory management.

### Multi-dimensional Arrays

- Arrays with more than one dimension, useful for representing grids, matrices, etc.

## Linked Lists

### Singly Linked List

- A list where each element points to the next, allowing for efficient insertions and deletions.

### Doubly Linked List

- A list where each element points to both the next and previous elements, providing efficient bidirectional traversal.

### Circular Linked List

- A linked list where the last element points back to the first, forming a circle.

## Stacks

### Implementation using arrays and linked lists

- **Array-based Stacks:** Simple but may require resizing.
- **Linked List-based Stacks:** More flexible with efficient dynamic memory usage.

### Applications of stacks

- **Expression Evaluation:** Using stacks to evaluate postfix or prefix expressions.
- **Backtracking:** Using stacks to remember choices while exploring possibilities (e.g., in puzzles).

## Queues

### Simple Queue

- A basic FIFO (First-In-First-Out) structure.

### Circular Queue

- A queue where the end wraps around to the beginning, optimizing space usage.

### Priority Queue

- A queue where elements are dequeued based on priority rather than order of insertion.

### Deque (Double-ended Queue)

- A queue where elements can be added or removed from both ends.

## Hash Tables (Hash Maps)

### Hashing Techniques

- Techniques to convert keys into indices (e.g., division method, multiplication method).

### Collision Handling

- **Chaining:** Using linked lists to handle collisions at each bucket.
- **Open Addressing:** Finding another open slot within the table (e.g., linear probing, quadratic probing).

## Trees

### Binary Trees

- Trees where each node has at most two children.

### Binary Search Trees (BST)

- Binary trees with the left child smaller and the right child larger than the parent node.

### AVL Trees

- Self-balancing BSTs where the height difference between left and right subtrees is at most 1.

### Red-Black Trees

- Self-balancing BSTs with additional properties to ensure balance after insertions and deletions.

### Heaps (Min-Heap, Max-Heap)

- Complete binary trees used to implement priority queues, where the parent node is either smaller (min-heap) or larger (max-heap) than its children.

### Tries (Prefix Trees)

- Trees used to store a dynamic set of strings where keys are usually strings.

## Graphs

### Representation

- **Adjacency Matrix:** A 2D array to represent graph connections.
- **Adjacency List:** An array of lists to represent graph connections more efficiently.

### Directed and Undirected Graphs

- **Directed Graphs:** Edges have a direction.
- **Undirected Graphs:** Edges have no direction.

### Weighted Graphs

- Graphs where edges have weights or costs associated with them.

## Advanced Data Structures

### Segment Trees

- Trees used for answering range queries efficiently.

### Fenwick Trees (Binary Indexed Trees)

- Data structures that provide efficient methods for cumulative frequency tables.

### Disjoint Set (Union-Find)

- Data structures to keep track of a partition of a set into disjoint subsets.

## Algorithms

### Sorting Algorithms

#### Bubble Sort

- Repeatedly swaps adjacent elements if they are in the wrong order.

#### Selection Sort

- Selects the smallest (or largest) element and swaps it with the first unsorted element.

#### Insertion Sort

- Builds the final sorted array one item at a time.

#### Merge Sort

- Divides the array into halves, sorts them, and merges them back together.

#### Quick Sort

- Picks an element as a pivot and partitions the array around the pivot.

#### Heap Sort

- Uses a heap to repeatedly extract the maximum element.

#### Counting Sort

- Counts the number of objects with distinct key values.

#### Radix Sort

- Sorts numbers by processing individual digits.

#### Bucket Sort

- Distributes elements into buckets and sorts each bucket individually.

### Searching Algorithms

#### Linear Search

- Searches for an element by checking each element in the array sequentially.

#### Binary Search

- Searches a sorted array by repeatedly dividing the search interval in half.

### Graph Algorithms

#### Depth-First Search (DFS)

- Explores as far as possible along each branch before backtracking.

#### Breadth-First Search (BFS)

- Explores all neighbors at the present depth before moving on to nodes at the next depth level.

#### Dijkstra’s Algorithm

- Finds the shortest path from a single source to all other nodes in a weighted graph.

#### Bellman-Ford Algorithm

- Computes shortest paths from a single source, allowing for negative weights.

#### Floyd-Warshall Algorithm

- Computes shortest paths between all pairs of nodes.

#### Prim’s Algorithm (Minimum Spanning Tree)

- Finds a minimum spanning tree for a weighted undirected graph.

#### Kruskal’s Algorithm (Minimum Spanning Tree)

- Finds a minimum spanning tree by sorting edges and adding them to the tree if they don’t form a cycle.

#### Topological Sort

- Orders nodes in a directed acyclic graph (DAG).

### Dynamic Programming

#### Memoization vs Tabulation

- **Memoization:** Top-down approach using recursion and caching.
- **Tabulation:** Bottom-up approach using iterative computation.

#### Common Problems

- **Knapsack:** Maximizes the total value without exceeding the weight capacity.
- **Longest Common Subsequence:** Finds the longest subsequence common to two sequences.
- **Longest Increasing Subsequence:** Finds the longest subsequence that is strictly increasing.
- **Fibonacci Sequence:** Computes the Fibonacci numbers efficiently.

### Greedy Algorithms

#### Common Problems

- **Activity Selection:** Selects the maximum number of activities that don’t overlap.
- **Huffman Coding:** Constructs an optimal prefix code for a set of symbols.
- **Coin Change Problem:** Finds the minimum number of coins for a given amount.

### Divide and Conquer

#### Common Problems

- **Merge Sort:** Divides the array, sorts, and merges.
- **Quick Sort:** Partitions the array and sorts the partitions.
- **Binary Search:** Recursively divides the search interval.
- **Strassen’s Matrix Multiplication:** Multiplies matrices faster than the standard method.

### Backtracking

#### Common Problems

- **N-Queens Problem:** Places N queens on an N×N chessboard so that no two queens threaten each other.
- **Sudoku Solver:** Solves the Sudoku puzzle.
- **Subset Sum Problem:** Finds a subset that sums to a given value.

### String Algorithms

#### String Matching Algorithms

- **Naive:** Checks for the presence of a pattern in the text.
- **KMP (Knuth-Morris-Pratt):** Searches for a pattern using a partial match table.
- **Rabin-Karp:** Uses hashing to find a pattern.

#### Trie-based Algorithms

- Uses a trie (prefix tree) for efficient string manipulation.

#### Longest Common Substring

- Finds the longest substring common to two strings.

#### Longest Palindromic Substring

- Finds the longest substring that is a palindrome.

## Additional Concepts

### Bit Manipulation

#### Basic Bit Operations

- Operations like AND, OR, XOR, NOT, bit shifts, etc.

#### Applications in optimization and problem-solving

- Efficient solutions using bitwise operations (e.g., checking power of two).

### Recursion

#### Understanding base cases and recursive cases

- Key concepts for writing recursive functions.

#### Tail Recursion

- Recursion where the recursive call is the last operation, allowing for optimization.
